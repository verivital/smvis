MODULE main
-- Python algorithm (bubble sort on 3 elements):
--   # pass 1
--   if a0 > a1: a0, a1 = a1, a0
--   if a1 > a2: a1, a2 = a2, a1
--   # pass 2
--   if a0 > a1: a0, a1 = a1, a0
--   # done: a0 <= a1 <= a2

VAR
    a0 : 0..4;
    a1 : 0..4;
    a2 : 0..4;
    pc : {cmp01, swap01, cmp12, swap12, cmp01b, swap01b, done};

ASSIGN
    -- a0, a1, a2 unconstrained initially (all permutations)
    init(pc) := cmp01;

    next(pc) := case
        pc = cmp01 & a0 > a1 : swap01;
        pc = cmp01 & a0 <= a1 : cmp12;
        pc = swap01 : cmp12;
        pc = cmp12 & a1 > a2 : swap12;
        pc = cmp12 & a1 <= a2 : cmp01b;
        pc = swap12 : cmp01b;
        pc = cmp01b & a0 > a1 : swap01b;
        pc = cmp01b & a0 <= a1 : done;
        pc = swap01b : done;
        TRUE : pc;
    esac;

    next(a0) := case
        pc = swap01 : a1;
        pc = swap01b : a1;
        TRUE : a0;
    esac;

    next(a1) := case
        pc = swap01 : a0;
        pc = swap12 : a2;
        pc = swap01b : a0;
        TRUE : a1;
    esac;

    next(a2) := case
        pc = swap12 : a1;
        TRUE : a2;
    esac;

-- sorted at the end
INVARSPEC pc = done -> (a0 <= a1 & a1 <= a2)

-- algorithm terminates
CTLSPEC AF (pc = done)

-- elements stay in range
INVARSPEC a0 <= 4 & a1 <= 4 & a2 <= 4

-- minimum is in a0 at the end
INVARSPEC pc = done -> (a0 <= a1 & a0 <= a2)

-- maximum is in a2 at the end
INVARSPEC pc = done -> (a2 >= a0 & a2 >= a1)

-- can reach a state where all elements are equal
CTLSPEC EF (a0 = a1 & a1 = a2)

-- once done, stays done
LTLSPEC G (pc = done -> G (pc = done))
